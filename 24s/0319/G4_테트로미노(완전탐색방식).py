'''
5 5
1 2 3 4 5
5 4 3 2 1
2 3 4 5 6
6 5 4 3 2
1 2 1 2 1

4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5

4 10
1 2 1 2 1 2 1 2 1 2
2 1 2 1 2 1 2 1 2 1
1 2 1 2 1 2 1 2 1 2
2 1 2 1 2 1 2 1 2 1

'''
# 구현, 브루트포스

import sys
input = sys.stdin.readline

N, M = map(int, input().split())
board = [list(map(int, input().split())) for _ in range(N)]

# 가능한 기준점으로부터 모든 패턴의 회전/대칭 좌표(3개)를 저장
patern = [[(0, 1), (0, 2), (0, 3)], [(1, 0), (2, 0), (3, 0)],       # ㅡ 모양
          [(0, 1), (1, 0), (1, 1)],                                 # 사각형
          [(1, 0), (2, 0), (2, 1)], [(0, 1), (0, 2), (1, 0)], [(0, 1), (1, 1), (2, 1)], [(0, 1), (0, 2), (-1, 2)],      # ㄴ 회전모양
          [(0, 1), (-1, 1), (-2, 1)], [(1, 0), (1, 1), (1, 2)], [(0, 1), (1, 0), (2, 0)], [(0, 1), (0, 2), (1, 2)],     # ㄴ 대칭회전모양
          [(1, 0), (1, 1), (2, 1)], [(0, 1), (-1, 1), (-1, 2)],                 # ㄹ 회전
          [(1, 0), (0, 1), (-1, 1)], [(0, 1), (1, 1), (1, 2)],                  # ㄹ 대칭회전
          [(0, 1), (0, 2), (1, 1)], [(-1, 1), (0, 1), (1, 1)], [(0, 1), (0, 2), (-1, 1)], [(1, 0), (2, 0), (1, 1)]      # ㅗ 회전
          ]

def cal(i, j, pos):
    now = board[i][j]           # 기준값을 저장
    for dx, dy in pos:
        ni = i + dx
        nj = j + dy
        if 0 <= ni < N and 0 <= nj < M:
            now += board[ni][nj]

    return now


ans = 0

for i in range(N):
    for j in range(M):
        for pos in patern:
            temp = cal(i, j, pos)
            ans = max(ans, temp)

print(ans)